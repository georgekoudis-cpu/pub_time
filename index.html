<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MeetYouThere</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,600;0,700;1,700&display=swap" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    :root {
      --midnight: #24282C;
      --soft-grey: #F3F4F6;
      --electric-mint: #3DDC97;
      --electric-blue: #3DDCD7;
      --peach: #FF9F7F;
      --white: #FFFFFF;
      --selected-bg: #303337;
      --primary-blue: #272A47;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Roboto', -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; display: flex; height: 100vh; color: var(--white); background: var(--midnight); }

    #main { display: flex; flex: 1; min-height: 0; width: 100%; }

    /* --- Sidebar --- */
    #sidebar-wrap { position: relative; flex-shrink: 0; display: flex; }
    #sidebar { width: 424px; min-width: 424px; background: var(--midnight); overflow-y: auto; transition: width 0.25s ease, min-width 0.25s ease; display: flex; flex-direction: column; }
    #sidebar-wrap.collapsed #sidebar { width: 0; min-width: 0; overflow: hidden; }

    /* Sidebar toggle arrow */
    #sidebar-toggle { position: absolute; top: 29px; right: -30px; width: 30px; height: 100px; background: var(--midnight); border: none; border-radius: 0 10px 10px 0; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; color: var(--white); z-index: 500; padding: 0; }
    #sidebar-toggle:hover { opacity: 0.85; }

    /* --- Brand / Header --- */
    .brand-header { display: flex; align-items: center; padding: 36px 48px; border-bottom: 1px solid var(--soft-grey); }
    .brand { font-size: 24px; font-weight: 700; color: var(--white); letter-spacing: -0.3px; }
    .brand .peach { color: var(--peach); }

    /* --- Sidebar content --- */
    .sidebar-content { padding: 24px 48px 0; display: flex; flex-direction: column; gap: 12px; }

    /* --- Address rows --- */
    .addr-row { display: flex; gap: 12px; align-items: center; margin-bottom: 8px; }
    .addr-pin { width: 24px; height: 24px; flex-shrink: 0; display: flex; align-items: center; justify-content: center; }
    .addr-pin svg { width: 20px; height: 20px; }
    .addr-wrap { flex: 1; position: relative; }
    .addr-wrap input {
      width: 100%; padding: 12px 20px; font-size: 16px; line-height: 19px;
      background: rgba(255, 255, 255, 0.1); border: 1px solid var(--white);
      border-radius: 100px; color: var(--white); font-family: inherit; font-weight: 400;
    }
    .addr-wrap input::placeholder { color: rgba(255,255,255,0.5); }
    .addr-wrap input:focus { outline: none; border-color: var(--electric-mint); }
    .ac-list { position: absolute; top: 100%; left: 10px; right: 10px; background: var(--midnight); border: 1px solid var(--soft-grey); border-top: none; border-radius: 0 0 12px 12px; max-height: 200px; overflow-y: auto; z-index: 1000; display: none; }
    .ac-list div { padding: 10px 16px; font-size: 14px; cursor: pointer; color: var(--white); }
    .ac-list div:hover, .ac-list div.active { background: var(--selected-bg); }
    .ac-list div small { color: rgba(255,255,255,0.5); }
    .addr-label { display: none; }
    .remove-btn { background: none; border: none; color: rgba(255,255,255,0.5); font-size: 18px; cursor: pointer; padding: 4px 8px; line-height: 1; border-radius: 4px; }
    .remove-btn:hover { color: var(--white); }

    /* --- Buttons --- */
    .btn-row { display: flex; align-items: center; gap: 24px; }
    #addFriendBtn { background: transparent; border: none; color: var(--white); font-size: 16px; cursor: pointer; font-family: inherit; font-weight: 700; padding: 12px 0; display: flex; align-items: center; gap: 10px; }
    #addFriendBtn:hover { opacity: 0.8; }
    #findBtn { display: none; }

    #error { color: #ef5350; font-size: 14px; margin-top: 4px; padding: 0 48px; }
    #error:empty { display: none; }

    /* --- Map container --- */
    .map-container { flex: 1; min-height: 0; position: relative; display: flex; flex-direction: column; }
    #map { flex: 1; min-height: 0; }

    /* --- Footer on map --- */
    .map-footer {
      display: flex; align-items: center; justify-content: center;
      padding: 12px 240px; background: var(--soft-grey);
      border-top: 1px solid var(--midnight);
      font-size: 16px; line-height: 19px; font-weight: 400;
      color: var(--midnight); text-align: center;
    }

    /* --- Info / Results area --- */
    #info { font-size: 16px; line-height: 19px; }

    /* --- Drive chips (on selected venue) --- */
    .drive-info {
      display: flex; align-items: center; padding: 12px;
      background: rgba(61, 220, 215, 0.15); border: 1px solid var(--electric-blue);
      border-radius: 10px; font-style: italic; font-weight: 700;
      font-size: 14px; line-height: 16px; color: var(--white); gap: 10px;
    }

    /* --- Venue toggle tabs --- */
    .venue-toggle { display: flex; border-bottom: 1px solid var(--white); padding-top: 12px; }
    .venue-toggle button {
      flex: 1; background: none; border: none; border-bottom: 5px solid transparent;
      font-size: 16px; font-family: inherit; font-weight: 700; cursor: pointer;
      color: var(--white); padding: 12px 24px 24px; text-align: center;
      transition: color 0.15s, border-color 0.15s;
    }
    .venue-toggle button.active { color: var(--electric-mint); border-bottom-color: var(--electric-mint); }
    .venue-toggle button:hover:not(.active) { opacity: 0.8; }

    /* --- Venue list --- */
    #pubs-list { }
    #pubs-list h3 { font-size: 16px; margin-bottom: 6px; color: var(--white); font-weight: 600; padding: 16px 48px 0; }
    #pubs-list .venue-list { list-style: none; margin: 0; padding: 0; }

    #pubs-list .venue-item {
      display: flex; flex-direction: column; justify-content: center;
      padding: 24px 48px; gap: 10px; cursor: pointer;
      background: var(--midnight); border-bottom: 1px solid var(--white);
    }
    #pubs-list .venue-item:hover { background: var(--selected-bg); }
    #pubs-list .venue-item.selected {
      background: var(--selected-bg); border-left: 5px solid var(--electric-blue);
      padding-left: 43px; box-shadow: 0px 4px 4px rgba(0, 0, 0, 0.25);
    }
    #pubs-list .venue-name { font-weight: 600; color: var(--white); font-size: 16px; line-height: 19px; }
    #pubs-list .venue-item.selected .venue-name { font-weight: 700; font-size: 24px; line-height: 28px; }
    #pubs-list .venue-meta { color: var(--white); font-size: 16px; line-height: 19px; font-weight: 400; }
    #pubs-list a.review-link { display: none; }

    /* --- Venue detail --- */
    .pub-detail { margin: 0; }
    .pub-detail-card {
      padding: 24px 48px; background: var(--midnight);
    }
    .pub-detail-card h3 { font-size: 24px; line-height: 28px; margin-bottom: 8px; color: var(--white); font-weight: 700; }
    .pub-detail-card .pub-meta { font-size: 16px; color: var(--white); line-height: 19px; font-weight: 400; margin-bottom: 12px; }
    .pub-detail-card .pub-photo { width: 100%; max-height: 180px; object-fit: cover; border-radius: 8px; margin-bottom: 10px; }
    .pub-detail-card .pub-links { display: flex; gap: 10px; margin-top: 12px; flex-wrap: wrap; }
    .pub-detail-card .pub-links a {
      display: inline-block; padding: 8px 16px; background: var(--electric-mint);
      color: var(--midnight); border-radius: 8px; text-decoration: none;
      font-size: 14px; font-weight: 700;
    }
    .pub-detail-card .pub-links a:hover { opacity: 0.85; }
    .pub-detail-card .pub-links a.secondary { background: var(--soft-grey); color: var(--midnight); }

    /* --- Leaflet popup dark theme --- */
    .leaflet-popup-content-wrapper {
      background: var(--midnight) !important; color: var(--white) !important;
      border-radius: 0 0 10px 10px !important;
      box-shadow: 0px 4px 4px rgba(0, 0, 0, 0.25) !important;
      padding: 0 !important;
    }
    .leaflet-popup-tip { background: var(--midnight) !important; }
    .leaflet-popup-content {
      font-family: 'Roboto', sans-serif; font-size: 16px; line-height: 19px;
      margin: 0 !important; width: auto !important;
    }
    .popup-header {
      background: var(--electric-blue); padding: 12px 24px; border-radius: 10px 10px 0 0;
      font-style: italic; font-weight: 700; font-size: 14px; line-height: 16px;
      color: var(--midnight);
    }
    .popup-body { padding: 16px 24px; }
    .popup-body b { color: var(--white); font-weight: 700; font-size: 16px; }
    .popup-body a { color: var(--electric-mint) !important; text-decoration: none; }
    .popup-body a:hover { text-decoration: underline; }
    .leaflet-popup-close-button { color: var(--midnight) !important; font-size: 20px !important; top: 8px !important; right: 10px !important; }
    .leaflet-popup-close-button:hover { color: var(--white) !important; }

    /* Leaflet controls */
    .leaflet-control-attribution { background: rgba(36,40,44,0.7) !important; color: rgba(255,255,255,0.5) !important; font-size: 10px !important; }
    .leaflet-control-attribution a { color: rgba(255,255,255,0.5) !important; }
  </style>
</head>
<body>
  <div id="main">
    <div id="sidebar-wrap">
      <div id="sidebar">
        <div class="brand-header">
          <div class="brand"><span class="peach">M</span>eet<span class="peach">Y</span>ou<span class="peach">T</span>here.</div>
        </div>
        <div class="sidebar-content">
          <div id="addr-fields"></div>
          <div class="btn-row">
            <button id="addFriendBtn" onclick="addFriend()">
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none"><path d="M12 5v14M5 12h14" stroke="white" stroke-width="2" stroke-linecap="round"/></svg>
              Add Friend
            </button>
          </div>
        </div>
        <div id="error"></div>
        <div id="info"></div>
      </div>
      <button id="sidebar-toggle" onclick="toggleSidebar()" title="Collapse sidebar">&#9654;</button>
    </div>
    <div class="map-container">
      <div id="map"></div>
      <div class="map-footer">&copy; 2026 MeetYouThere Ltd. We'll meet you halfway.</div>
    </div>
  </div>
  <script>
    const map = L.map('map').setView([39.8283, -98.5795], 4);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        pos => map.setView([pos.coords.latitude, pos.coords.longitude], 11),
        () => ipGeolocate()
      );
    } else {
      ipGeolocate();
    }
    function ipGeolocate() {
      fetch('https://freeipapi.com/api/json')
        .then(r => r.json())
        .then(data => {
          if (data.latitude && data.longitude) map.setView([data.latitude, data.longitude], 11);
        })
        .catch(() => {});
    }

    const ROUTE_COLORS = ['#E8683F', '#3DDC97', '#7C4DFF', '#3DDCD7', '#FF9F7F', '#0d6efd', '#d63384', '#20c997'];
    let addrCount = 0;

    function pinSVG() {
      return '<svg class="addr-pin" width="24" height="24" viewBox="0 0 24 24" fill="none"><circle cx="12" cy="12" r="8" fill="white"/></svg>';
    }

    function addAddressField(label, placeholder, removable) {
      addrCount++;
      const id = addrCount;
      const row = document.createElement('div');
      row.className = 'addr-row';
      row.id = `addr-row-${id}`;
      row.innerHTML =
        pinSVG() +
        `<input type="text" class="addr-label" value="${label}" />` +
        `<div class="addr-wrap"><input type="text" id="addr-${id}" placeholder="${placeholder}" autocomplete="off" /><div class="ac-list" id="ac-${id}"></div></div>` +
        (removable ? `<button class="remove-btn" onclick="removeFriend(${id})" title="Remove">&times;</button>` : '');
      document.getElementById('addr-fields').appendChild(row);
      setupAutocomplete(`addr-${id}`, `ac-${id}`);
    }

    function removeFriend(id) {
      const row = document.getElementById(`addr-row-${id}`);
      if (row) row.remove();
    }

    function addFriend() {
      const friendNum = document.querySelectorAll('.addr-row').length;
      addAddressField(`Friend ${friendNum}`, `Friend ${friendNum}'s location`, true);
    }

    addAddressField('You', 'Your location', false);
    addAddressField('Friend 1', "Friend 1's location", true);

    function setupAutocomplete(inputId, listId) {
      const input = document.getElementById(inputId);
      const list = document.getElementById(listId);
      let debounceTimer = null;
      let activeIdx = -1;
      let items = [];

      input.addEventListener('input', () => {
        clearTimeout(debounceTimer);
        const q = input.value.trim();
        if (q.length < 3) { list.style.display = 'none'; return; }
        debounceTimer = setTimeout(async () => {
          try {
            const params = new URLSearchParams({ q, limit: '5' });
            const c = map.getCenter();
            params.set('lat', c.lat); params.set('lon', c.lng);
            const res = await fetch(`https://photon.komoot.io/api/?${params}`);
            const data = await res.json();
            items = data.features || [];
            activeIdx = -1;
            if (!items.length) { list.style.display = 'none'; return; }
            list.innerHTML = items.map((f, i) => {
              const p = f.properties;
              const parts = [p.name, p.street, p.city, p.state, p.country].filter(Boolean);
              return `<div data-idx="${i}">${parts[0]}${parts.length > 1 ? ' <small>' + parts.slice(1).join(', ') + '</small>' : ''}</div>`;
            }).join('');
            list.style.display = 'block';
          } catch (e) { list.style.display = 'none'; }
        }, 300);
      });

      list.addEventListener('mousedown', e => {
        const el = e.target.closest('[data-idx]');
        if (!el) return;
        selectItem(parseInt(el.dataset.idx));
      });

      input.addEventListener('keydown', e => {
        if (list.style.display === 'none' || !items.length) {
          if (e.key === 'Enter') findMidpoint();
          return;
        }
        if (e.key === 'ArrowDown') { e.preventDefault(); activeIdx = Math.min(activeIdx + 1, items.length - 1); highlight(); }
        else if (e.key === 'ArrowUp') { e.preventDefault(); activeIdx = Math.max(activeIdx - 1, 0); highlight(); }
        else if (e.key === 'Enter' && activeIdx >= 0) { e.preventDefault(); selectItem(activeIdx); }
        else if (e.key === 'Escape') { list.style.display = 'none'; }
      });

      input.addEventListener('blur', () => { setTimeout(() => list.style.display = 'none', 150); });

      function highlight() {
        list.querySelectorAll('div').forEach((d, i) => d.classList.toggle('active', i === activeIdx));
      }

      function selectItem(idx) {
        const f = items[idx];
        const p = f.properties;
        const parts = [p.name, p.housenumber, p.street, p.city, p.postcode, p.state, p.country].filter(Boolean);
        input.value = parts.join(', ');
        list.style.display = 'none';
      }
    }

    let markers = [];
    let routeLayers = [];
    let pubMarkers = [];
    let lastMid = null;
    let lastLabels = [];
    let lastRoutes = [];
    let currentVenueType = 'pubs';

    function toggleSidebar() {
      const wrap = document.getElementById('sidebar-wrap');
      const btn = document.getElementById('sidebar-toggle');
      wrap.classList.toggle('collapsed');
      btn.innerHTML = wrap.classList.contains('collapsed') ? '&#9654;' : '&#9664;';
      btn.title = wrap.classList.contains('collapsed') ? 'Expand sidebar' : 'Collapse sidebar';
      setTimeout(() => map.invalidateSize(), 260);
    }

    const redIcon = L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png', shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] });
    const pubIcon = L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-gold.png', shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] });

    const OVERPASS_SERVERS = [
      'https://overpass-api.de/api/interpreter',
      'https://overpass.kumi.systems/api/interpreter',
      'https://maps.mail.ru/osm/tools/overpass/api/interpreter',
    ];

    async function queryOverpass(query) {
      for (const server of OVERPASS_SERVERS) {
        try {
          const res = await fetch(server, { method: 'POST', body: `data=${encodeURIComponent(query)}` });
          if (!res.ok) continue;
          return await res.json();
        } catch (e) { continue; }
      }
      throw new Error('All Overpass servers unavailable');
    }

    const VENUE_CONFIG = {
      pubs: {
        tags: [['amenity', 'pub'], ['amenity', 'bar']],
        fallbackName: 'Unnamed pub',
        label: 'pubs',
        websiteLabel: 'Pub website',
      },
      restaurants: {
        tags: [['amenity', 'restaurant'], ['amenity', 'cafe']],
        fallbackName: 'Unnamed restaurant',
        label: 'restaurants',
        websiteLabel: 'Restaurant website',
      },
      parks: {
        tags: [['leisure', 'park'], ['leisure', 'garden']],
        fallbackName: 'Unnamed park',
        label: 'parks',
        websiteLabel: 'Website',
      },
    };

    async function findNearbyVenues(lat, lon, type) {
      const config = VENUE_CONFIG[type];
      const radius = 5000;
      const tagQueries = config.tags.map(([k, v]) =>
        `node["${k}"="${v}"](around:${radius},${lat},${lon});way["${k}"="${v}"](around:${radius},${lat},${lon});`
      ).join('');
      const query = `[out:json][timeout:25];(${tagQueries});out center body;`;
      const data = await queryOverpass(query);
      const venues = data.elements.map(el => {
        const elLat = el.lat ?? el.center?.lat;
        const elLon = el.lon ?? el.center?.lon;
        if (!elLat || !elLon) return null;
        const d = Math.sqrt((elLat - lat) ** 2 + (elLon - lon) ** 2) * 111320;
        const t = el.tags || {};
        return {
          name: t.name || config.fallbackName, lat: elLat, lon: elLon, dist: d,
          addr: [t['addr:housenumber'], t['addr:street'], t['addr:city']].filter(Boolean).join(', '),
          website: t.website || t['contact:website'] || '',
          phone: t.phone || t['contact:phone'] || '',
          openingHours: t.opening_hours || '',
          cuisine: t.cuisine || '',
          image: t.image || '',
          wikidata: t.wikidata || '',
        };
      });
      venues.sort((a, b) => a.dist - b.dist);
      return venues.filter(Boolean).slice(0, 5);
    }

    function googleMapsSearchUrl(name, lat, lon) {
      return `https://www.google.com/maps/search/${encodeURIComponent(name)}/@${lat},${lon},17z`;
    }

    async function getWikidataImage(qid) {
      try {
        const res = await fetch(`https://www.wikidata.org/wiki/Special:EntityData/${qid}.json`);
        const data = await res.json();
        const imgClaim = data.entities[qid]?.claims?.P18?.[0]?.mainsnak?.datavalue?.value;
        if (imgClaim) {
          const filename = imgClaim.replace(/ /g, '_');
          const md5 = await hashMD5(filename);
          return `https://upload.wikimedia.org/wikipedia/commons/thumb/${md5[0]}/${md5[0]}${md5[1]}/${filename}/400px-${filename}`;
        }
      } catch (e) {}
      return '';
    }

    async function hashMD5(str) {
      const buf = await crypto.subtle.digest('MD5', new TextEncoder().encode(str)).catch(() => null);
      if (buf) return [...new Uint8Array(buf)].map(b => b.toString(16).padStart(2, '0')).join('');
      return md5mini(str);
    }

    function md5mini(s) {
      function md5cycle(x, k) {
        let a = x[0], b = x[1], c = x[2], d = x[3];
        a=ff(a,b,c,d,k[0],7,-680876936);d=ff(d,a,b,c,k[1],12,-389564586);c=ff(c,d,a,b,k[2],17,606105819);b=ff(b,c,d,a,k[3],22,-1044525330);
        a=ff(a,b,c,d,k[4],7,-176418897);d=ff(d,a,b,c,k[5],12,1200080426);c=ff(c,d,a,b,k[6],17,-1473231341);b=ff(b,c,d,a,k[7],22,-45705983);
        a=ff(a,b,c,d,k[8],7,1770035416);d=ff(d,a,b,c,k[9],12,-1958414417);c=ff(c,d,a,b,k[10],17,-42063);b=ff(b,c,d,a,k[11],22,-1990404162);
        a=ff(a,b,c,d,k[12],7,1804603682);d=ff(d,a,b,c,k[13],12,-40341101);c=ff(c,d,a,b,k[14],17,-1502002290);b=ff(b,c,d,a,k[15],22,1236535329);
        a=gg(a,b,c,d,k[1],5,-165796510);d=gg(d,a,b,c,k[6],9,-1069501632);c=gg(c,d,a,b,k[11],14,643717713);b=gg(b,c,d,a,k[0],20,-373897302);
        a=gg(a,b,c,d,k[5],5,-701558691);d=gg(d,a,b,c,k[10],9,38016083);c=gg(c,d,a,b,k[15],14,-660478335);b=gg(b,c,d,a,k[4],20,-405537848);
        a=gg(a,b,c,d,k[9],5,568446438);d=gg(d,a,b,c,k[14],9,-1019803690);c=gg(c,d,a,b,k[3],14,-187363961);b=gg(b,c,d,a,k[8],20,1163531501);
        a=gg(a,b,c,d,k[13],5,-1444681467);d=gg(d,a,b,c,k[2],9,-51403784);c=gg(c,d,a,b,k[7],14,1735328473);b=gg(b,c,d,a,k[12],20,-1926607734);
        a=hh(a,b,c,d,k[5],4,-378558);d=hh(d,a,b,c,k[8],11,-2022574463);c=hh(c,d,a,b,k[11],16,1839030562);b=hh(b,c,d,a,k[14],23,-35309556);
        a=hh(a,b,c,d,k[1],4,-1530992060);d=hh(d,a,b,c,k[4],11,1272893353);c=hh(c,d,a,b,k[7],16,-155497632);b=hh(b,c,d,a,k[10],23,-1094730640);
        a=hh(a,b,c,d,k[13],4,681279174);d=hh(d,a,b,c,k[0],11,-358537222);c=hh(c,d,a,b,k[3],16,-722521979);b=hh(b,c,d,a,k[6],23,76029189);
        a=hh(a,b,c,d,k[9],4,-640364487);d=hh(d,a,b,c,k[12],11,-421815835);c=hh(c,d,a,b,k[15],16,530742520);b=hh(b,c,d,a,k[2],23,-995338651);
        a=ii(a,b,c,d,k[0],6,-198630844);d=ii(d,a,b,c,k[7],10,1126891415);c=ii(c,d,a,b,k[14],15,-1416354905);b=ii(b,c,d,a,k[5],21,-57434055);
        a=ii(a,b,c,d,k[12],6,1700485571);d=ii(d,a,b,c,k[3],10,-1894986606);c=ii(c,d,a,b,k[10],15,-1051523);b=ii(b,c,d,a,k[1],21,-2054922799);
        a=ii(a,b,c,d,k[8],6,1873313359);d=ii(d,a,b,c,k[15],10,-30611744);c=ii(c,d,a,b,k[6],15,-1560198380);b=ii(b,c,d,a,k[13],21,1309151649);
        a=ii(a,b,c,d,k[4],6,-145523070);d=ii(d,a,b,c,k[11],10,-1120210379);c=ii(c,d,a,b,k[2],15,718787259);b=ii(b,c,d,a,k[9],21,-343485551);
        x[0]=add32(a,x[0]);x[1]=add32(b,x[1]);x[2]=add32(c,x[2]);x[3]=add32(d,x[3]);
      }
      function cmn(q,a,b,x,s,t){a=add32(add32(a,q),add32(x,t));return add32((a<<s)|(a>>>(32-s)),b)}
      function ff(a,b,c,d,x,s,t){return cmn((b&c)|((~b)&d),a,b,x,s,t)}
      function gg(a,b,c,d,x,s,t){return cmn((b&d)|(c&(~d)),a,b,x,s,t)}
      function hh(a,b,c,d,x,s,t){return cmn(b^c^d,a,b,x,s,t)}
      function ii(a,b,c,d,x,s,t){return cmn(c^(b|(~d)),a,b,x,s,t)}
      function add32(a,b){return(a+b)&0xFFFFFFFF}
      const n=s.length;let state=[1732584193,-271733879,-1732584194,271733878],i;
      for(i=64;i<=n;i+=64){const k=[];for(let j=i-64;j<i;j+=4)k.push(s.charCodeAt(j)|(s.charCodeAt(j+1)<<8)|(s.charCodeAt(j+2)<<16)|(s.charCodeAt(j+3)<<24));md5cycle(state,k)}
      const tail=[];for(let j=i-64;j<n;j++)tail.push(s.charCodeAt(j));tail.push(0x80);while(tail.length%64!==56)tail.push(0);
      const bl=n*8;tail.push(bl&0xff,(bl>>8)&0xff,(bl>>16)&0xff,(bl>>24)&0xff,0,0,0,0);
      const k=[];for(let j=0;j<tail.length;j+=4)k.push(tail[j]|(tail[j+1]<<8)|(tail[j+2]<<16)|(tail[j+3]<<24));
      for(let j=0;j<k.length;j+=16)md5cycle(state,k.slice(j,j+16));
      const hex=[];for(let j=0;j<4;j++)for(let jj=0;jj<4;jj++)hex.push(((state[j]>>(jj*8))&0xff).toString(16).padStart(2,'0'));
      return hex.join('');
    }

    async function getRoute(fromLat, fromLon, toLat, toLon) {
      const url = `https://router.project-osrm.org/route/v1/driving/${fromLon},${fromLat};${toLon},${toLat}?overview=full&geometries=geojson`;
      const res = await fetch(url);
      const data = await res.json();
      if (data.code !== 'Ok' || !data.routes.length) return null;
      return { duration: data.routes[0].duration, distance: data.routes[0].distance, geometry: data.routes[0].geometry };
    }

    function formatDuration(seconds) {
      const h = Math.floor(seconds / 3600);
      const m = Math.round((seconds % 3600) / 60);
      return h > 0 ? `${h} hr ${m} min` : `${m} min`;
    }

    function formatDistance(meters) {
      const miles = meters / 1609.34;
      return miles >= 10 ? `${Math.round(miles)} mi` : `${miles.toFixed(1)} mi`;
    }

    async function geocode(address) {
      const url = `https://nominatim.openstreetmap.org/search?${new URLSearchParams({ q: address, format: 'json', limit: '1' })}`;
      const res = await fetch(url, { headers: { 'User-Agent': 'MidpointFinderApp/1.0' } });
      const data = await res.json();
      if (!data.length) throw new Error(`Address not found: "${address}"`);
      return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon), name: data[0].display_name };
    }

    function buildDriveInfoHTML() {
      if (!lastRoutes) return '';
      const parts = lastRoutes.map((route, i) => {
        return `${lastLabels[i]}: ${formatDuration(route.duration)} \u2022 ${formatDistance(route.distance)}`;
      });
      return `<div class="drive-info">${parts.join(' | ')}</div>`;
    }

    async function showPubDetail(pub, idx) {
      const detailEl = document.getElementById('pub-detail');
      if (!detailEl) return;

      // Highlight selected venue
      document.querySelectorAll('#pubs-list .venue-item').forEach((el, i) => {
        el.classList.toggle('selected', i === idx);
      });

      const gmapsUrl = googleMapsSearchUrl(pub.name, pub.lat, pub.lon);
      let photoHTML = '';
      if (pub.image) {
        photoHTML = `<img class="pub-photo" src="${pub.image}" alt="${pub.name}" onerror="this.style.display='none'" />`;
      } else if (pub.wikidata) {
        detailEl.innerHTML = `<div class="pub-detail-card"><p>Loading details...</p></div>`;
        const imgUrl = await getWikidataImage(pub.wikidata);
        if (imgUrl) photoHTML = `<img class="pub-photo" src="${imgUrl}" alt="${pub.name}" onerror="this.style.display='none'" />`;
      }
      let metaLines = [];
      if (pub.addr) metaLines.push(pub.addr);
      if (pub.phone) metaLines.push(`Phone: ${pub.phone}`);
      if (pub.openingHours) metaLines.push(`Hours: ${pub.openingHours}`);
      if (pub.cuisine) metaLines.push(`Cuisine: ${pub.cuisine}`);
      detailEl.innerHTML = `<div class="pub-detail-card">
        ${photoHTML}
        <div class="pub-meta">${metaLines.join('<br>')}</div>
        ${buildDriveInfoHTML()}
        <div class="pub-links">
          ${pub.website ? `<a href="${pub.website}" target="_blank">${VENUE_CONFIG[currentVenueType].websiteLabel}</a>` : ''}
          <a href="${gmapsUrl}" target="_blank" class="${pub.website ? 'secondary' : ''}">Google Maps</a>
        </div>
      </div>`;
    }

    async function optimizeMidpoint(locations, statusEl) {
      let candLat = locations.reduce((s, l) => s + l.lat, 0) / locations.length;
      let candLon = locations.reduce((s, l) => s + l.lon, 0) / locations.length;

      let bestLat = candLat, bestLon = candLon;
      let bestRoutes = null;
      let bestMaxDur = Infinity;

      let step = 0.3;
      const iterations = locations.length === 2 ? 6 : 7;

      for (let i = 0; i < iterations; i++) {
        if (statusEl) statusEl.textContent = `Optimizing (${i + 1}/${iterations})...`;

        const routes = await Promise.all(
          locations.map(l => getRoute(l.lat, l.lon, candLat, candLon))
        );

        if (routes.some(r => !r)) break;

        const durations = routes.map(r => r.duration);
        const maxDur = Math.max(...durations);
        const minDur = Math.min(...durations);

        if (maxDur < bestMaxDur) {
          bestLat = candLat; bestLon = candLon;
          bestRoutes = routes; bestMaxDur = maxDur;
        }

        if (maxDur - minDur < 60) break;

        const maxIdx = durations.indexOf(maxDur);
        const target = locations[maxIdx];
        candLat += (target.lat - candLat) * step;
        candLon += (target.lon - candLon) * step;

        step *= 0.7;
      }

      if (bestLat !== candLat || bestLon !== candLon) {
        const finalRoutes = await Promise.all(
          locations.map(l => getRoute(l.lat, l.lon, bestLat, bestLon))
        );
        if (finalRoutes.every(r => r)) bestRoutes = finalRoutes;
      }

      return { lat: bestLat, lon: bestLon, routes: bestRoutes };
    }

    function renderVenueToggle(activeType) {
      const types = ['pubs', 'restaurants', 'parks'];
      const labels = { pubs: 'Pubs', restaurants: 'Restaurants', parks: 'Parks' };
      return `<div class="venue-toggle">` +
        types.map(t => `<button class="${t === activeType ? 'active' : ''}" onclick="switchVenueType('${t}')">${labels[t]}</button>`).join('') +
        `</div>`;
    }

    async function loadVenues(type, lat, lon, bounds, statusEl) {
      const config = VENUE_CONFIG[type];
      const resultsEl = document.getElementById('venue-results');
      if (!resultsEl) return;

      if (statusEl) statusEl.textContent = `Finding ${config.label}...`;
      resultsEl.innerHTML = `<div id="pubs-list"><h3>Searching for ${config.label}...</h3></div>`;

      let venues = [];
      let venueError = '';
      try { venues = await findNearbyVenues(lat, lon, type); } catch (e) { venueError = e.message; console.warn('Venue search failed:', e); }

      if (venues.length) {
        venues.forEach((v, i) => {
          const gmapsUrl = googleMapsSearchUrl(v.name, v.lat, v.lon);
          const driveText = lastRoutes ? lastRoutes.map((r, ri) =>
            `${lastLabels[ri]}: ${formatDuration(r.duration)} \u2022 ${formatDistance(r.distance)}`
          ).join(' | ') : '';
          const popupContent = `<div class="popup-header">${driveText}</div><div class="popup-body"><b>${v.name}</b>${v.addr ? '<br>' + v.addr : ''}<br><a href="${gmapsUrl}" target="_blank">View on Google Maps</a></div>`;
          const pm = L.marker([v.lat, v.lon], { icon: pubIcon }).addTo(map)
            .bindPopup(popupContent, { maxWidth: 400, minWidth: 280 });
          pubMarkers.push(pm);
          if (bounds) bounds.extend([v.lat, v.lon]);
        });
        let metaForVenue = (v) => {
          let parts = [];
          if (v.addr) parts.push(v.addr);
          if (v.openingHours) parts.push(v.openingHours);
          return parts.join(' \u2022 ');
        };
        resultsEl.innerHTML = `<div id="pubs-list"><ul class="venue-list">` +
          venues.map((v, i) => {
            return `<li class="venue-item${i === 0 ? ' selected' : ''}" data-idx="${i}"><div class="venue-name">${v.name}</div><div class="venue-meta">${metaForVenue(v)}</div></li>`;
          }).join('') + `</ul><div id="pub-detail"></div></div>`;

        // Auto-show first venue detail with drive info
        showPubDetail(venues[0], 0);

        resultsEl.querySelectorAll('#pubs-list .venue-item').forEach(li => {
          li.addEventListener('click', () => {
            const idx = parseInt(li.dataset.idx);
            pubMarkers[idx].openPopup();
            map.panTo(pubMarkers[idx].getLatLng());
            showPubDetail(venues[idx], idx);
          });
        });
      } else {
        resultsEl.innerHTML = `<div id="pubs-list"><p style="color:rgba(255,255,255,0.5); padding: 24px 48px;">${venueError ? 'Search failed â€” try again. (' + venueError + ')' : `No ${config.label} found within 5 km.`}</p></div>`;
      }
    }

    async function switchVenueType(type) {
      if (type === currentVenueType || !lastMid) return;
      currentVenueType = type;
      document.querySelectorAll('.venue-toggle button').forEach(btn => {
        btn.classList.toggle('active', btn.textContent.toLowerCase() === type);
      });
      pubMarkers.forEach(m => map.removeLayer(m));
      pubMarkers = [];
      await loadVenues(type, lastMid.lat, lastMid.lon, null, null);
    }

    async function findMidpoint() {
      const inputs = document.querySelectorAll('#addr-fields .addr-wrap input');
      const addresses = [...inputs].map(el => el.value.trim());
      const errorEl = document.getElementById('error');
      errorEl.textContent = '';

      if (addresses.some(a => !a)) { errorEl.textContent = 'Please enter all addresses.'; return; }
      if (addresses.length < 2) { errorEl.textContent = 'Need at least 2 locations.'; return; }

      markers.forEach(m => map.removeLayer(m));
      markers = [];
      routeLayers.forEach(l => map.removeLayer(l));
      routeLayers = [];
      pubMarkers.forEach(m => map.removeLayer(m));
      pubMarkers = [];
      document.getElementById('info').innerHTML = '';

      // Use addFriendBtn as status indicator
      const statusEl = document.getElementById('addFriendBtn');
      const origHTML = statusEl.innerHTML;
      statusEl.disabled = true;
      statusEl.textContent = 'Geocoding...';

      try {
        const locations = [];
        for (let i = 0; i < addresses.length; i++) {
          statusEl.textContent = `Geocoding (${i + 1}/${addresses.length})...`;
          locations.push(await geocode(addresses[i]));
          if (i < addresses.length - 1) await new Promise(r => setTimeout(r, 300));
        }

        const labels = [...document.querySelectorAll('#addr-fields .addr-label')].map(el => el.value || 'Person');

        locations.forEach((loc, i) => {
          const color = ROUTE_COLORS[i % ROUTE_COLORS.length];
          const m = L.marker([loc.lat, loc.lon]).addTo(map)
            .bindPopup(`<div class="popup-body"><b>${labels[i]}</b><br>${loc.name}</div>`);
          markers.push(m);
        });

        const mid = await optimizeMidpoint(locations, statusEl);

        const m3 = L.marker([mid.lat, mid.lon], { icon: redIcon }).addTo(map);
        markers.push(m3);

        const bounds = L.latLngBounds(locations.map(l => [l.lat, l.lon]));
        bounds.extend([mid.lat, mid.lon]);

        if (mid.routes) {
          mid.routes.forEach((route, i) => {
            const color = ROUTE_COLORS[i % ROUTE_COLORS.length];
            const line = L.geoJSON(route.geometry, { style: { color, weight: 4, opacity: 0.7 } }).addTo(map);
            routeLayers.push(line);
            bounds.extend(line.getBounds());
          });
        }

        lastMid = { lat: mid.lat, lon: mid.lon };
        lastLabels = labels;
        lastRoutes = mid.routes;
        currentVenueType = 'pubs';

        let midPopupDrives = '';
        if (mid.routes) {
          midPopupDrives = mid.routes.map((r, i) =>
            `${labels[i]}: ${formatDuration(r.duration)} \u2022 ${formatDistance(r.distance)}`
          ).join(' | ');
        }
        m3.bindPopup(
          `<div class="popup-header">${midPopupDrives}</div><div class="popup-body"><b>Drive-time midpoint</b><br>${mid.lat.toFixed(5)}, ${mid.lon.toFixed(5)}</div>`,
          { maxWidth: 400, minWidth: 280 }
        );

        const infoEl = document.getElementById('info');
        let infoHTML = renderVenueToggle('pubs');
        infoHTML += `<div id="venue-results"></div>`;
        infoEl.innerHTML = infoHTML;
        map.invalidateSize();

        await loadVenues('pubs', mid.lat, mid.lon, bounds, statusEl);

        map.fitBounds(bounds, { padding: [40, 40] });
        m3.openPopup();
      } catch (e) {
        errorEl.textContent = e.message;
      } finally {
        statusEl.disabled = false;
        statusEl.innerHTML = origHTML;
      }
    }

    // Trigger search on Enter from any address input
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && e.target.matches('.addr-wrap input')) {
        const acList = e.target.parentElement.querySelector('.ac-list');
        if (acList && acList.style.display !== 'none') return;
        findMidpoint();
      }
    });
  </script>
</body>
</html>
