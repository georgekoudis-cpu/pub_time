<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>MeetYouThere</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,600;0,700;1,700&display=swap" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <style>
    /* === Figma Design Tokens === */
    :root {
      --midnight: #24282C;
      --soft-grey: #F3F4F6;
      --electric-mint: #3DDC97;
      --electric-blue: #3DDCD7;
      --peach: #FF9F7F;
      --white: #FFFFFF;
      --selected-bg: #303337;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    /* === Body: Roboto font, dark background === */
    body { font-family: 'Roboto', -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; margin: 0; color: var(--white); background: var(--midnight); }

    /* === Controls bar (top) — Figma: sidebar header style === */
    .controls { padding: 24px 36px; background: var(--midnight); border-bottom: 1px solid var(--soft-grey); }

    #main { display: flex; flex: 1; min-height: 0; }

    /* === Address rows === */
    .addr-row { display: flex; gap: 12px; align-items: center; margin-bottom: 12px; }

    /* === Address input fields — Figma: pill shape, translucent bg, white border === */
    .addr-wrap { flex: 1; position: relative; }
    .addr-wrap input {
      width: 100%; padding: 12px 72px 12px 20px; height: 43px;
      border: 1px solid var(--white); border-radius: 100px;
      font-size: 16px; line-height: 19px; font-weight: 400;
      background: rgba(255, 255, 255, 0.1); color: var(--white); font-family: inherit;
    }
    .addr-wrap input::placeholder { color: rgba(255,255,255,0.5); }
    .addr-wrap input:focus { outline: none; border-color: var(--electric-mint); }

    /* === Autocomplete dropdown — dark themed === */
    .ac-list { position: absolute; top: 100%; left: 10px; right: 10px; background: var(--midnight); border: 1px solid var(--soft-grey); border-top: none; border-radius: 0 0 12px 12px; max-height: 200px; overflow-y: auto; z-index: 1000; display: none; }
    .ac-list div { padding: 10px 16px; font-size: 14px; cursor: pointer; color: var(--white); }
    .ac-list div:hover, .ac-list div.active { background: var(--selected-bg); }
    .ac-list div small { color: rgba(255,255,255,0.5); }

    /* === Address labels — hidden per Figma === */
    .addr-label { display: none; }

    /* === Remove button === */
    .remove-btn { background: none; border: none; color: rgba(255,255,255,0.5); font-size: 18px; cursor: pointer; padding: 4px 8px; line-height: 1; border-radius: 4px; }
    .remove-btn:hover { color: var(--white); }

    /* === Button row === */
    .btn-row { display: flex; gap: 24px; align-items: center; }
    .btn-row button { padding: 12px; border: none; border-radius: 6px; font-size: 16px; line-height: 19px; cursor: pointer; white-space: nowrap; font-family: inherit; font-weight: 700; }

    /* === "Let's Meet!" button — Figma: white bold text === */
    #findBtn { background: var(--electric-mint); color: var(--midnight); padding: 12px 24px; border-radius: 100px; }
    #findBtn:hover { opacity: 0.9; }
    #findBtn:disabled { opacity: 0.5; cursor: not-allowed; }

    /* === "+ Add friend" button — Figma: white bold, no border === */
    #addFriendBtn { background: transparent; color: var(--white); border: none; font-size: 16px; font-weight: 700; }
    #addFriendBtn:hover { opacity: 0.8; }

    /* === Map === */
    #map { flex: 1; min-height: 0; }

    /* === Error === */
    #error { color: var(--peach); font-size: 14px; margin-top: 8px; }
    #error:empty { display: none; }

    /* === Sidebar — Figma: midnight bg, always on left === */
    #sidebar-wrap { display: none; position: relative; flex-shrink: 0; }
    #sidebar-wrap.visible { display: flex; }
    #sidebar { width: 402px; min-width: 402px; border-right: none; overflow-y: auto; background: var(--midnight); transition: width 0.25s ease, min-width 0.25s ease; }
    #sidebar-wrap.collapsed #sidebar { width: 0; min-width: 0; overflow: hidden; }

    /* === Sidebar toggle — Figma: midnight bg, rounded right corners === */
    #sidebar-toggle { position: absolute; top: 29px; right: -30px; width: 30px; height: 100px; background: var(--midnight); border: none; border-radius: 0 10px 10px 0; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 16px; color: var(--white); z-index: 500; padding: 0; }
    #sidebar-toggle:hover { opacity: 0.85; }

    /* === Info panel === */
    #info { padding: 0; font-size: 16px; line-height: 19px; }

    /* === Drive routes info === */
    .drives { display: flex; flex-direction: column; gap: 10px; padding: 24px 36px; }
    .drives .route { font-size: 16px; line-height: 19px; color: var(--white); }
    .drives .route b { display: block; margin-bottom: 2px; }

    /* === Venue list === */
    #pubs-list { margin-top: 0; padding-top: 0; border-top: none; }
    #pubs-list h3 { font-size: 16px; margin-bottom: 6px; color: var(--white); font-weight: 600; padding: 0 36px; }
    #pubs-list ol { margin: 0; padding: 0; list-style: none; }
    #pubs-list li {
      padding: 24px 36px; cursor: pointer; color: var(--white);
      font-size: 16px; line-height: 19px; font-weight: 600;
      background: var(--midnight); border-bottom: 1px solid var(--white);
    }
    #pubs-list li:hover { background: var(--selected-bg); text-decoration: none; }
    #pubs-list li span { color: var(--white); font-size: 16px; font-weight: 400; display: block; margin-top: 4px; }
    #pubs-list li a.review-link { color: var(--electric-mint); font-size: 14px; font-weight: 700; margin-left: 0; text-decoration: none; display: block; margin-top: 4px; }
    #pubs-list li a.review-link:hover { text-decoration: underline; }

    /* === Pub detail card — Figma: selected-bg, padded === */
    .pub-detail { margin-top: 0; padding: 24px 36px; background: var(--selected-bg); border-radius: 0; border: none; border-left: 5px solid var(--electric-blue); box-shadow: 0px 4px 4px rgba(0, 0, 0, 0.25); }
    .pub-detail h3 { font-size: 24px; line-height: 28px; margin-bottom: 10px; color: var(--white); font-weight: 700; }
    .pub-detail .pub-meta { font-size: 16px; color: var(--white); line-height: 19px; font-weight: 400; }
    .pub-detail .pub-photo { width: 100%; max-height: 200px; object-fit: cover; border-radius: 8px; margin-bottom: 10px; }
    .pub-detail .pub-links { display: flex; gap: 10px; margin-top: 12px; flex-wrap: wrap; }
    .pub-detail .pub-links a { display: inline-block; padding: 8px 16px; background: var(--electric-mint); color: var(--midnight); border-radius: 8px; text-decoration: none; font-size: 14px; font-weight: 700; }
    .pub-detail .pub-links a:hover { opacity: 0.85; }
    .pub-detail .pub-links a.secondary { background: var(--soft-grey); color: var(--midnight); }
    .pub-detail .pub-links a.secondary:hover { opacity: 0.85; }

    /* === Venue toggle tabs — Figma: white bottom border, mint active, white inactive === */
    .venue-toggle { display: flex; gap: 0; margin-top: 0; margin-bottom: 0; border-radius: 0; overflow: visible; border: none; border-bottom: 1px solid var(--white); padding: 12px 0 0; }
    .venue-toggle button {
      flex: 1; padding: 12px 24px 24px; border: none; border-bottom: 5px solid transparent;
      font-size: 16px; font-family: inherit; font-weight: 700; cursor: pointer;
      background: transparent; color: var(--white);
      transition: color 0.15s, border-color 0.15s;
    }
    .venue-toggle button.active { color: var(--electric-mint); border-bottom-color: var(--electric-mint); }
    .venue-toggle button:not(:last-child) { border-right: none; }
    .venue-toggle button:hover:not(.active) { opacity: 0.8; }

    /* === Leaflet popup — Figma: cyan header, midnight body === */
    .leaflet-popup-content-wrapper {
      background: var(--midnight) !important; color: var(--white) !important;
      border-radius: 10px !important;
      box-shadow: 0px 4px 4px rgba(0, 0, 0, 0.25) !important;
      padding: 0 !important;
    }
    .leaflet-popup-tip { background: var(--midnight) !important; }
    .leaflet-popup-content { font-family: 'Roboto', sans-serif; font-size: 16px; line-height: 19px; margin: 12px 16px !important; }
    .leaflet-popup-content a { color: var(--electric-mint) !important; }
    .leaflet-popup-content b { color: var(--white); font-weight: 700; }
    .leaflet-popup-close-button { color: rgba(255,255,255,0.5) !important; font-size: 20px !important; }
    .leaflet-popup-close-button:hover { color: var(--white) !important; }

    /* === Leaflet controls — dark themed === */
    .leaflet-control-attribution { background: rgba(36,40,44,0.7) !important; color: rgba(255,255,255,0.5) !important; font-size: 10px !important; }
    .leaflet-control-attribution a { color: rgba(255,255,255,0.5) !important; }

    /* === Footer — Figma: midnight bg, white border-top === */
    .map-footer {
      display: flex; align-items: center; justify-content: center;
      padding: 24px; background: var(--midnight);
      border-top: 1px solid var(--white);
      font-size: 16px; line-height: 19px; font-weight: 400;
      color: var(--white); text-align: center;
    }

    /* === View switching === */
    .view { display: none; flex-direction: column; height: 100vh; }
    .view.active { display: flex; }
    #app-view { display: none; }
    #app-view.active { display: flex; }

    /* === Landing page === */
    #landing-view {
      background: var(--midnight);
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }
    .landing-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 100%;
      max-width: 557px;
      padding: 0 24px 100px;
      min-height: 0;
    }
    .brand-text {
      font-size: 48px;
      font-weight: 700;
      color: var(--white);
      text-align: center;
      line-height: 1.1;
    }
    .brand-text .highlight { color: var(--peach); }
    .landing-subtitle {
      font-size: 16px;
      color: var(--white);
      text-align: center;
      margin-top: 12px;
    }
    .landing-fields {
      width: 100%;
      margin-top: 60px;
      display: flex;
      flex-direction: column;
      gap: 24px;
      flex-shrink: 1;
      min-height: 0;
      overflow: visible;
    }
    .landing-fields.scrollable {
      overflow-y: auto;
      padding-right: 4px;
      padding-bottom: 220px;
    }
    .landing-field-group { display: flex; flex-direction: column; gap: 6px; }
    .landing-field-label {
      font-size: 16px;
      color: var(--white);
      padding: 0 12px;
    }
    .landing-field-group .addr-wrap { width: 100%; }
    .landing-field-group .addr-wrap input {
      width: 100%; padding: 12px 72px 12px 20px; height: 43px;
      border: 1px solid var(--white); border-radius: 100px;
      font-size: 16px; line-height: 19px; font-weight: 400;
      background: rgba(255, 255, 255, 0.1); color: var(--white); font-family: inherit;
    }
    .landing-field-group .addr-wrap input::placeholder { color: rgba(255,255,255,0.5); }
    .landing-field-group .addr-wrap input:focus { outline: none; border-color: var(--electric-mint); }
    #landing-add-friend {
      background: transparent;
      border: none;
      color: var(--white);
      font-size: 16px;
      font-weight: 700;
      font-family: inherit;
      width: 137px;
      cursor: pointer;
      text-align: left;
      padding: 0;
      margin-top: 24px;
    }
    #landing-add-friend:hover { opacity: 0.8; }
    #landing-meet-btn {
      width: 100%;
      height: 43px;
      margin-top: 60px;
      background: var(--electric-mint);
      color: var(--midnight);
      border: none;
      border-radius: 100px;
      font-size: 16px;
      font-weight: 700;
      font-family: inherit;
      cursor: pointer;
    }
    #landing-meet-btn:hover { opacity: 0.9; }
    #landing-meet-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    #landing-error {
      color: var(--peach);
      font-size: 14px;
      margin-top: 8px;
      text-align: center;
    }
    #landing-error:empty { display: none; }
    .landing-footer {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 24px;
      border-top: 1px solid var(--white);
      font-size: 16px;
      line-height: 19px;
      font-weight: 400;
      color: var(--white);
      text-align: center;
      background: var(--midnight);
    }

    /* === Loading page === */
    #loading-view {
      background: var(--midnight);
      align-items: center;
      justify-content: center;
    }
    .loading-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 60px;
    }
    .loading-heading {
      font-size: 20px;
      line-height: 24px;
      font-weight: 600;
      color: var(--white);
      text-align: center;
    }
    .loading-details {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 24px;
      width: 742px;
      max-width: 90vw;
    }
    .loading-status {
      font-size: 16px;
      line-height: 19px;
      font-weight: 400;
      color: var(--white);
      text-align: center;
      width: 100%;
    }
    .loading-bar-track {
      box-sizing: border-box;
      width: 100%;
      height: 56px;
      padding: 12px;
      border: 2px solid var(--electric-mint);
      border-radius: 100px;
      overflow: hidden;
      display: flex;
      gap: 10px;
    }
    .loading-bar-fill {
      height: 32px;
      border-radius: 100px;
      background: linear-gradient(90deg, #3DDC97 1.58%, #3DDCD7 100.2%);
      width: 0%;
      transition: width 0.4s ease;
    }
    .loading-hint {
      font-size: 14px;
      line-height: 17px;
      font-weight: 400;
      font-style: italic;
      color: var(--white);
      text-align: center;
      width: 100%;
    }
  </style>
</head>
<body>
  <!-- === Landing View === -->
  <div id="landing-view" class="view active">
    <div class="landing-content">
      <div class="brand-text"><span class="highlight">M</span>eet<span class="highlight">Y</span>ou<span class="highlight">T</span>here<span class="highlight">.</span></div>
      <div class="landing-subtitle">Add each location below and we'll find the perfect place to meet</div>
      <div class="landing-fields" id="landing-fields">
        <div class="landing-field-group">
          <label class="landing-field-label">Your location</label>
          <div class="addr-wrap"><input type="text" id="landing-addr-1" placeholder="Your location" autocomplete="off" /><div class="ac-list" id="landing-ac-1"></div></div>
        </div>
        <div class="landing-field-group">
          <label class="landing-field-label">Friend 1's location</label>
          <div class="addr-wrap"><input type="text" id="landing-addr-2" placeholder="Friend 1's location" autocomplete="off" /><div class="ac-list" id="landing-ac-2"></div></div>
        </div>
      </div>
      <button id="landing-add-friend" onclick="addLandingFriend()">+ Add friend</button>
      <button id="landing-meet-btn" onclick="handleLandingSubmit()">Let's Meet!</button>
      <div id="landing-error"></div>
    </div>
    <div class="landing-footer">&copy; 2026 MeetYouThere Ltd. We'll meet you halfway.</div>
  </div>

  <!-- === Loading View === -->
  <div id="loading-view" class="view">
    <div class="loading-content">
      <div class="brand-text"><span class="highlight">M</span>eet<span class="highlight">Y</span>ou<span class="highlight">T</span>here<span class="highlight">.</span></div>
      <div class="loading-details">
        <div class="loading-heading">Hold tight, we are just generating your meeting points</div>
        <div id="loading-status" class="loading-status">Generating...</div>
        <div class="loading-bar-track">
          <div id="loading-bar-fill" class="loading-bar-fill"></div>
        </div>
        <div class="loading-hint">This usually takes 1 minute</div>
      </div>
    </div>
    <div class="landing-footer">&copy; 2026 MeetYouThere Ltd. We'll meet you halfway.</div>
  </div>

  <!-- === App View (existing map page) === -->
  <div id="app-view" class="view">
    <div class="controls">
      <div id="addr-fields"></div>
      <div class="btn-row">
        <button id="addFriendBtn" onclick="addFriend()">+ Add friend</button>
        <button id="findBtn" onclick="findMidpoint()">Let's Meet!</button>
      </div>
      <div id="error"></div>
    </div>
    <div id="main">
      <div id="sidebar-wrap"><div id="sidebar"><div id="info"></div></div><button id="sidebar-toggle" onclick="toggleSidebar()" title="Collapse sidebar">&#9664;</button></div>
      <div style="flex:1; display:flex; flex-direction:column; min-height:0;">
        <div id="map"></div>
        <div class="map-footer">&copy; 2026 MeetYouThere Ltd. We'll meet you halfway.</div>
      </div>
    </div>
  </div>
  <script>
    // === View switching ===
    function showView(id) {
      document.querySelectorAll('.view').forEach(v => v.classList.remove('active'));
      document.getElementById(id).classList.add('active');
      if (id === 'app-view') {
        setTimeout(() => map.invalidateSize(), 50);
      }
      if (id === 'loading-view') {
        // Reset progress bar
        document.getElementById('loading-bar-fill').style.width = '0%';
        document.getElementById('loading-status').textContent = 'Generating...';
      }
    }

    function updateLoadingProgress(percent, status) {
      const fill = document.getElementById('loading-bar-fill');
      const statusEl = document.getElementById('loading-status');
      if (fill) fill.style.width = percent + '%';
      if (statusEl && status) statusEl.textContent = status;
    }

    // === Landing page: scrollable check ===
    function checkLandingScroll() {
      const fields = document.getElementById('landing-fields');
      // Compare the natural content height to the available space
      fields.classList.remove('scrollable');
      const needsScroll = fields.scrollHeight > fields.clientHeight;
      fields.classList.toggle('scrollable', needsScroll);
    }

    // === Landing page: add friend ===
    let landingFriendCount = 1;
    function addLandingFriend() {
      landingFriendCount++;
      const num = landingFriendCount;
      const group = document.createElement('div');
      group.className = 'landing-field-group';
      group.id = `landing-group-${num}`;
      group.innerHTML =
        `<label class="landing-field-label">Friend ${num}'s location</label>` +
        `<div style="display:flex; gap:8px; align-items:center;">` +
          `<div class="addr-wrap" style="flex:1;"><input type="text" id="landing-addr-${num + 1}" placeholder="Friend ${num}'s location" autocomplete="off" /><div class="ac-list" id="landing-ac-${num + 1}"></div></div>` +
          `<button class="remove-btn" onclick="removeLandingFriend('landing-group-${num}')" title="Remove">&times;</button>` +
        `</div>`;
      document.getElementById('landing-fields').appendChild(group);
      setupAutocomplete(`landing-addr-${num + 1}`, `landing-ac-${num + 1}`);
      checkLandingScroll();
    }

    function removeLandingFriend(id) {
      const el = document.getElementById(id);
      if (el) el.remove();
      checkLandingScroll();
    }

    // === Landing page: submit ===
    function handleLandingSubmit() {
      const landingInputs = document.querySelectorAll('#landing-fields .addr-wrap input');
      const addresses = [...landingInputs].map(el => el.value.trim());
      const errorEl = document.getElementById('landing-error');
      errorEl.textContent = '';

      if (addresses.some(a => !a)) {
        errorEl.textContent = 'Please enter all addresses.';
        return;
      }
      if (addresses.length < 2) {
        errorEl.textContent = 'Need at least 2 locations.';
        return;
      }

      // Reset app address fields to match landing inputs
      const addrFieldsEl = document.getElementById('addr-fields');
      addrFieldsEl.innerHTML = '';
      addrCount = 0;

      // Re-create app address fields with the values from landing
      addresses.forEach((addr, i) => {
        const label = i === 0 ? 'You' : `Friend ${i}`;
        const placeholder = i === 0 ? 'Your location' : `Friend ${i}'s location`;
        addAddressField(label, placeholder, i > 0);
        // Set the value from the landing input
        document.getElementById(`addr-${i + 1}`).value = addr;
      });

      // Show loading, then run search
      showView('loading-view');
      // Small delay so loading view renders before heavy work
      setTimeout(() => findMidpoint(), 50);
    }

    const map = L.map('map').setView([39.8283, -98.5795], 4);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
    }).addTo(map);

    // Centre map on user's location
    if (navigator.geolocation) {
      navigator.geolocation.getCurrentPosition(
        pos => map.setView([pos.coords.latitude, pos.coords.longitude], 11),
        () => ipGeolocate()
      );
    } else {
      ipGeolocate();
    }
    function ipGeolocate() {
      fetch('https://freeipapi.com/api/json')
        .then(r => r.json())
        .then(data => {
          if (data.latitude && data.longitude) map.setView([data.latitude, data.longitude], 11);
        })
        .catch(() => {});
    }

    // --- Dynamic address fields ---
    const ROUTE_COLORS = ['#0d6efd', '#198754', '#e85d04', '#6f42c1', '#d63384', '#20c997', '#fd7e14', '#0dcaf0'];
    let addrCount = 0;

    function addAddressField(label, placeholder, removable) {
      addrCount++;
      const id = addrCount;
      const row = document.createElement('div');
      row.className = 'addr-row';
      row.id = `addr-row-${id}`;
      row.innerHTML =
        `<input type="text" class="addr-label" value="${label}" />` +
        `<div class="addr-wrap"><input type="text" id="addr-${id}" placeholder="${placeholder}" autocomplete="off" /><div class="ac-list" id="ac-${id}"></div></div>` +
        (removable ? `<button class="remove-btn" onclick="removeFriend(${id})" title="Remove">&times;</button>` : '<span style="width:30px"></span>');
      document.getElementById('addr-fields').appendChild(row);
      setupAutocomplete(`addr-${id}`, `ac-${id}`);
    }

    function removeFriend(id) {
      const row = document.getElementById(`addr-row-${id}`);
      if (row) row.remove();
    }

    function addFriend() {
      const friendNum = document.querySelectorAll('.addr-row').length;
      addAddressField(`Friend ${friendNum}`, `Friend ${friendNum}'s location`, true);
    }

    // Initialize with 2 fields
    addAddressField('You', 'Your location', false);
    addAddressField('Friend 1', "Friend 1's location", true);

    // Landing page autocomplete will be set up after setupAutocomplete is defined

    // --- Retry-capable fetch ---
    async function fetchWithRetry(url, options = {}, retries = 2, delay = 1500) {
      let lastError;
      for (let i = 0; i <= retries; i++) {
        try {
          const res = await fetch(url, options);
          if (res.ok) return res;
          lastError = new Error(`HTTP ${res.status}`);
        } catch (e) {
          lastError = e;
        }
        if (i < retries) await new Promise(r => setTimeout(r, delay));
      }
      throw lastError;
    }

    // --- Autocomplete ---
    function setupAutocomplete(inputId, listId) {
      const input = document.getElementById(inputId);
      const list = document.getElementById(listId);
      let debounceTimer = null;
      let activeIdx = -1;
      let items = [];

      input.addEventListener('input', () => {
        clearTimeout(debounceTimer);
        const q = input.value.trim();
        if (q.length < 3) { list.style.display = 'none'; return; }
        debounceTimer = setTimeout(async () => {
          try {
            const params = new URLSearchParams({ q, limit: '5' });
            const c = map.getCenter();
            params.set('lat', c.lat); params.set('lon', c.lng);
            const res = await fetch(`https://photon.komoot.io/api/?${params}`);
            const data = await res.json();
            items = data.features || [];
            activeIdx = -1;
            if (!items.length) { list.style.display = 'none'; return; }
            list.innerHTML = items.map((f, i) => {
              const p = f.properties;
              const parts = [p.name, p.street, p.city, p.state, p.country].filter(Boolean);
              return `<div data-idx="${i}">${parts[0]}${parts.length > 1 ? ' <small>' + parts.slice(1).join(', ') + '</small>' : ''}</div>`;
            }).join('');
            list.style.display = 'block';
          } catch (e) { list.style.display = 'none'; }
        }, 300);
      });

      list.addEventListener('mousedown', e => {
        const el = e.target.closest('[data-idx]');
        if (!el) return;
        selectItem(parseInt(el.dataset.idx));
      });

      input.addEventListener('keydown', e => {
        if (list.style.display === 'none' || !items.length) {
          if (e.key === 'Enter') {
            if (input.id.startsWith('landing-')) handleLandingSubmit();
            else findMidpoint();
          }
          return;
        }
        if (e.key === 'ArrowDown') { e.preventDefault(); activeIdx = Math.min(activeIdx + 1, items.length - 1); highlight(); }
        else if (e.key === 'ArrowUp') { e.preventDefault(); activeIdx = Math.max(activeIdx - 1, 0); highlight(); }
        else if (e.key === 'Enter' && activeIdx >= 0) { e.preventDefault(); selectItem(activeIdx); }
        else if (e.key === 'Escape') { list.style.display = 'none'; }
      });

      input.addEventListener('blur', () => { setTimeout(() => list.style.display = 'none', 150); });

      function highlight() {
        list.querySelectorAll('div').forEach((d, i) => d.classList.toggle('active', i === activeIdx));
      }

      function selectItem(idx) {
        const f = items[idx];
        const p = f.properties;
        const parts = [p.name, p.housenumber, p.street, p.city, p.postcode, p.state, p.country].filter(Boolean);
        input.value = parts.join(', ');
        list.style.display = 'none';
      }
    }

    // Setup landing page autocomplete
    setupAutocomplete('landing-addr-1', 'landing-ac-1');
    setupAutocomplete('landing-addr-2', 'landing-ac-2');

    // --- Warm up API connections on page load ---
    // Pre-establish TLS/DNS so first real request doesn't fail
    setTimeout(() => {
      fetch('https://nominatim.openstreetmap.org/status', { mode: 'cors' }).catch(() => {});
      fetch('https://router.project-osrm.org/nearest/v1/driving/0,0', { mode: 'cors' }).catch(() => {});
      fetch('https://overpass-api.de/api/status', { mode: 'cors' }).catch(() => {});
    }, 500);

    // --- State ---
    let markers = [];
    let routeLayers = [];
    let pubMarkers = [];
    let lastMid = null;
    let lastLabels = [];
    let lastRoutes = [];
    let currentVenueType = 'pubs';

    function toggleSidebar() {
      const wrap = document.getElementById('sidebar-wrap');
      const btn = document.getElementById('sidebar-toggle');
      wrap.classList.toggle('collapsed');
      btn.innerHTML = wrap.classList.contains('collapsed') ? '&#9654;' : '&#9664;';
      btn.title = wrap.classList.contains('collapsed') ? 'Expand sidebar' : 'Collapse sidebar';
      setTimeout(() => map.invalidateSize(), 260);
    }

    const redIcon = L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-red.png', shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] });
    const pubIcon = L.icon({ iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-gold.png', shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png', iconSize: [25, 41], iconAnchor: [12, 41], popupAnchor: [1, -34], shadowSize: [41, 41] });

    const OVERPASS_SERVERS = [
      'https://overpass-api.de/api/interpreter',
      'https://overpass.kumi.systems/api/interpreter',
      'https://maps.mail.ru/osm/tools/overpass/api/interpreter',
    ];

    async function queryOverpass(query) {
      for (const server of OVERPASS_SERVERS) {
        try {
          const res = await fetchWithRetry(server, { method: 'POST', body: `data=${encodeURIComponent(query)}` }, 1, 1000);
          if (!res.ok) continue;
          return await res.json();
        } catch (e) { continue; }
      }
      throw new Error('All Overpass servers unavailable');
    }

    const VENUE_CONFIG = {
      pubs: {
        tags: [['amenity', 'pub'], ['amenity', 'bar']],
        fallbackName: 'Unnamed pub',
        label: 'pubs',
        websiteLabel: 'Pub website',
      },
      restaurants: {
        tags: [['amenity', 'restaurant'], ['amenity', 'cafe']],
        fallbackName: 'Unnamed restaurant',
        label: 'restaurants',
        websiteLabel: 'Restaurant website',
      },
      parks: {
        tags: [['leisure', 'park'], ['leisure', 'garden']],
        fallbackName: 'Unnamed park',
        label: 'parks',
        websiteLabel: 'Website',
      },
    };

    async function findNearbyVenues(lat, lon, type) {
      const config = VENUE_CONFIG[type];
      const radius = 5000;
      const tagQueries = config.tags.map(([k, v]) =>
        `node["${k}"="${v}"](around:${radius},${lat},${lon});way["${k}"="${v}"](around:${radius},${lat},${lon});`
      ).join('');
      const query = `[out:json][timeout:25];(${tagQueries});out center body;`;
      const data = await queryOverpass(query);
      const venues = data.elements.map(el => {
        const elLat = el.lat ?? el.center?.lat;
        const elLon = el.lon ?? el.center?.lon;
        if (!elLat || !elLon) return null;
        const d = Math.sqrt((elLat - lat) ** 2 + (elLon - lon) ** 2) * 111320;
        const t = el.tags || {};
        return {
          name: t.name || config.fallbackName, lat: elLat, lon: elLon, dist: d,
          addr: [t['addr:housenumber'], t['addr:street'], t['addr:city']].filter(Boolean).join(', '),
          website: t.website || t['contact:website'] || '',
          phone: t.phone || t['contact:phone'] || '',
          openingHours: t.opening_hours || '',
          cuisine: t.cuisine || '',
          image: t.image || '',
          wikidata: t.wikidata || '',
        };
      });
      venues.sort((a, b) => a.dist - b.dist);
      return venues.filter(Boolean).slice(0, 5);
    }

    function googleMapsSearchUrl(name, lat, lon) {
      return `https://www.google.com/maps/search/${encodeURIComponent(name)}/@${lat},${lon},17z`;
    }

    async function getWikidataImage(qid) {
      try {
        const res = await fetch(`https://www.wikidata.org/wiki/Special:EntityData/${qid}.json`);
        const data = await res.json();
        const imgClaim = data.entities[qid]?.claims?.P18?.[0]?.mainsnak?.datavalue?.value;
        if (imgClaim) {
          const filename = imgClaim.replace(/ /g, '_');
          const md5 = await hashMD5(filename);
          return `https://upload.wikimedia.org/wikipedia/commons/thumb/${md5[0]}/${md5[0]}${md5[1]}/${filename}/400px-${filename}`;
        }
      } catch (e) {}
      return '';
    }

    async function hashMD5(str) {
      const buf = await crypto.subtle.digest('MD5', new TextEncoder().encode(str)).catch(() => null);
      if (buf) return [...new Uint8Array(buf)].map(b => b.toString(16).padStart(2, '0')).join('');
      return md5mini(str);
    }

    function md5mini(s) {
      function md5cycle(x, k) {
        let a = x[0], b = x[1], c = x[2], d = x[3];
        a=ff(a,b,c,d,k[0],7,-680876936);d=ff(d,a,b,c,k[1],12,-389564586);c=ff(c,d,a,b,k[2],17,606105819);b=ff(b,c,d,a,k[3],22,-1044525330);
        a=ff(a,b,c,d,k[4],7,-176418897);d=ff(d,a,b,c,k[5],12,1200080426);c=ff(c,d,a,b,k[6],17,-1473231341);b=ff(b,c,d,a,k[7],22,-45705983);
        a=ff(a,b,c,d,k[8],7,1770035416);d=ff(d,a,b,c,k[9],12,-1958414417);c=ff(c,d,a,b,k[10],17,-42063);b=ff(b,c,d,a,k[11],22,-1990404162);
        a=ff(a,b,c,d,k[12],7,1804603682);d=ff(d,a,b,c,k[13],12,-40341101);c=ff(c,d,a,b,k[14],17,-1502002290);b=ff(b,c,d,a,k[15],22,1236535329);
        a=gg(a,b,c,d,k[1],5,-165796510);d=gg(d,a,b,c,k[6],9,-1069501632);c=gg(c,d,a,b,k[11],14,643717713);b=gg(b,c,d,a,k[0],20,-373897302);
        a=gg(a,b,c,d,k[5],5,-701558691);d=gg(d,a,b,c,k[10],9,38016083);c=gg(c,d,a,b,k[15],14,-660478335);b=gg(b,c,d,a,k[4],20,-405537848);
        a=gg(a,b,c,d,k[9],5,568446438);d=gg(d,a,b,c,k[14],9,-1019803690);c=gg(c,d,a,b,k[3],14,-187363961);b=gg(b,c,d,a,k[8],20,1163531501);
        a=gg(a,b,c,d,k[13],5,-1444681467);d=gg(d,a,b,c,k[2],9,-51403784);c=gg(c,d,a,b,k[7],14,1735328473);b=gg(b,c,d,a,k[12],20,-1926607734);
        a=hh(a,b,c,d,k[5],4,-378558);d=hh(d,a,b,c,k[8],11,-2022574463);c=hh(c,d,a,b,k[11],16,1839030562);b=hh(b,c,d,a,k[14],23,-35309556);
        a=hh(a,b,c,d,k[1],4,-1530992060);d=hh(d,a,b,c,k[4],11,1272893353);c=hh(c,d,a,b,k[7],16,-155497632);b=hh(b,c,d,a,k[10],23,-1094730640);
        a=hh(a,b,c,d,k[13],4,681279174);d=hh(d,a,b,c,k[0],11,-358537222);c=hh(c,d,a,b,k[3],16,-722521979);b=hh(b,c,d,a,k[6],23,76029189);
        a=hh(a,b,c,d,k[9],4,-640364487);d=hh(d,a,b,c,k[12],11,-421815835);c=hh(c,d,a,b,k[15],16,530742520);b=hh(b,c,d,a,k[2],23,-995338651);
        a=ii(a,b,c,d,k[0],6,-198630844);d=ii(d,a,b,c,k[7],10,1126891415);c=ii(c,d,a,b,k[14],15,-1416354905);b=ii(b,c,d,a,k[5],21,-57434055);
        a=ii(a,b,c,d,k[12],6,1700485571);d=ii(d,a,b,c,k[3],10,-1894986606);c=ii(c,d,a,b,k[10],15,-1051523);b=ii(b,c,d,a,k[1],21,-2054922799);
        a=ii(a,b,c,d,k[8],6,1873313359);d=ii(d,a,b,c,k[15],10,-30611744);c=ii(c,d,a,b,k[6],15,-1560198380);b=ii(b,c,d,a,k[13],21,1309151649);
        a=ii(a,b,c,d,k[4],6,-145523070);d=ii(d,a,b,c,k[11],10,-1120210379);c=ii(c,d,a,b,k[2],15,718787259);b=ii(b,c,d,a,k[9],21,-343485551);
        x[0]=add32(a,x[0]);x[1]=add32(b,x[1]);x[2]=add32(c,x[2]);x[3]=add32(d,x[3]);
      }
      function cmn(q,a,b,x,s,t){a=add32(add32(a,q),add32(x,t));return add32((a<<s)|(a>>>(32-s)),b)}
      function ff(a,b,c,d,x,s,t){return cmn((b&c)|((~b)&d),a,b,x,s,t)}
      function gg(a,b,c,d,x,s,t){return cmn((b&d)|(c&(~d)),a,b,x,s,t)}
      function hh(a,b,c,d,x,s,t){return cmn(b^c^d,a,b,x,s,t)}
      function ii(a,b,c,d,x,s,t){return cmn(c^(b|(~d)),a,b,x,s,t)}
      function add32(a,b){return(a+b)&0xFFFFFFFF}
      const n=s.length;let state=[1732584193,-271733879,-1732584194,271733878],i;
      for(i=64;i<=n;i+=64){const k=[];for(let j=i-64;j<i;j+=4)k.push(s.charCodeAt(j)|(s.charCodeAt(j+1)<<8)|(s.charCodeAt(j+2)<<16)|(s.charCodeAt(j+3)<<24));md5cycle(state,k)}
      const tail=[];for(let j=i-64;j<n;j++)tail.push(s.charCodeAt(j));tail.push(0x80);while(tail.length%64!==56)tail.push(0);
      const bl=n*8;tail.push(bl&0xff,(bl>>8)&0xff,(bl>>16)&0xff,(bl>>24)&0xff,0,0,0,0);
      const k=[];for(let j=0;j<tail.length;j+=4)k.push(tail[j]|(tail[j+1]<<8)|(tail[j+2]<<16)|(tail[j+3]<<24));
      for(let j=0;j<k.length;j+=16)md5cycle(state,k.slice(j,j+16));
      const hex=[];for(let j=0;j<4;j++)for(let jj=0;jj<4;jj++)hex.push(((state[j]>>(jj*8))&0xff).toString(16).padStart(2,'0'));
      return hex.join('');
    }

    async function getRoute(fromLat, fromLon, toLat, toLon) {
      const url = `https://router.project-osrm.org/route/v1/driving/${fromLon},${fromLat};${toLon},${toLat}?overview=full&geometries=geojson`;
      const res = await fetchWithRetry(url);
      const data = await res.json();
      if (data.code !== 'Ok' || !data.routes.length) return null;
      return { duration: data.routes[0].duration, distance: data.routes[0].distance, geometry: data.routes[0].geometry };
    }

    function formatDuration(seconds) {
      const h = Math.floor(seconds / 3600);
      const m = Math.round((seconds % 3600) / 60);
      return h > 0 ? `${h} hr ${m} min` : `${m} min`;
    }

    function formatDistance(meters) {
      const miles = meters / 1609.34;
      return miles >= 10 ? `${Math.round(miles)} mi` : `${miles.toFixed(1)} mi`;
    }

    async function geocode(address) {
      const url = `https://nominatim.openstreetmap.org/search?${new URLSearchParams({ q: address, format: 'json', limit: '1' })}`;
      const res = await fetchWithRetry(url, { headers: { 'User-Agent': 'MidpointFinderApp/1.0' } });
      const data = await res.json();
      if (!data.length) throw new Error(`Address not found: "${address}"`);
      return { lat: parseFloat(data[0].lat), lon: parseFloat(data[0].lon), name: data[0].display_name };
    }

    async function showPubDetail(pub) {
      const detailEl = document.getElementById('pub-detail');
      if (!detailEl) return;
      const gmapsUrl = googleMapsSearchUrl(pub.name, pub.lat, pub.lon);
      let photoHTML = '';
      if (pub.image) {
        photoHTML = `<img class="pub-photo" src="${pub.image}" alt="${pub.name}" onerror="this.style.display='none'" />`;
      } else if (pub.wikidata) {
        detailEl.innerHTML = `<div class="pub-detail"><p>Loading details...</p></div>`;
        const imgUrl = await getWikidataImage(pub.wikidata);
        if (imgUrl) photoHTML = `<img class="pub-photo" src="${imgUrl}" alt="${pub.name}" onerror="this.style.display='none'" />`;
      }
      let metaLines = [];
      if (pub.addr) metaLines.push(pub.addr);
      if (pub.phone) metaLines.push(`Phone: ${pub.phone}`);
      if (pub.openingHours) metaLines.push(`Hours: ${pub.openingHours}`);
      if (pub.cuisine) metaLines.push(`Cuisine: ${pub.cuisine}`);
      detailEl.innerHTML = `<div class="pub-detail">
        <h3>${pub.name}</h3>
        ${photoHTML}
        <div class="pub-meta">${metaLines.join('<br>')}</div>
        <div class="pub-links">
          ${pub.website ? `<a href="${pub.website}" target="_blank">${VENUE_CONFIG[currentVenueType].websiteLabel}</a>` : ''}
          <a href="${gmapsUrl}" target="_blank" class="${pub.website ? 'secondary' : ''}">Google Maps (reviews &amp; photos)</a>
        </div>
      </div>`;
    }

    // --- N-person drive-time midpoint optimization ---
    // Uses iterative approach: start at geographic centroid, then shift toward
    // whoever has the longest drive, shrinking the step each iteration.
    async function optimizeMidpoint(locations, btn) {
      // Geographic centroid as starting point
      let candLat = locations.reduce((s, l) => s + l.lat, 0) / locations.length;
      let candLon = locations.reduce((s, l) => s + l.lon, 0) / locations.length;

      let bestLat = candLat, bestLon = candLon;
      let bestRoutes = null;
      let bestMaxDur = Infinity;

      // Adaptive step size based on spread of locations
      const latSpread = Math.max(...locations.map(l => l.lat)) - Math.min(...locations.map(l => l.lat));
      const lonSpread = Math.max(...locations.map(l => l.lon)) - Math.min(...locations.map(l => l.lon));
      let step = 0.3;

      const iterations = locations.length === 2 ? 6 : 7;

      for (let i = 0; i < iterations; i++) {
        btn.textContent = `Optimizing (${i + 1}/${iterations})...`;
        updateLoadingProgress(25 + Math.round((i + 1) / iterations * 45), `Optimizing route ${i + 1} of ${iterations}...`);

        const routes = await Promise.all(
          locations.map(l => getRoute(l.lat, l.lon, candLat, candLon))
        );

        if (routes.some(r => !r)) break;

        const durations = routes.map(r => r.duration);
        const maxDur = Math.max(...durations);
        const minDur = Math.min(...durations);

        if (maxDur < bestMaxDur) {
          bestLat = candLat; bestLon = candLon;
          bestRoutes = routes; bestMaxDur = maxDur;
        }

        // Close enough — all drives within 1 minute of each other
        if (maxDur - minDur < 60) break;

        // Shift toward the person with the longest drive
        const maxIdx = durations.indexOf(maxDur);
        const target = locations[maxIdx];
        candLat += (target.lat - candLat) * step;
        candLon += (target.lon - candLon) * step;

        step *= 0.7; // shrink step
      }

      // Final route fetch at best point if we moved away
      if (bestLat !== candLat || bestLon !== candLon) {
        const finalRoutes = await Promise.all(
          locations.map(l => getRoute(l.lat, l.lon, bestLat, bestLon))
        );
        if (finalRoutes.every(r => r)) bestRoutes = finalRoutes;
      }

      return { lat: bestLat, lon: bestLon, routes: bestRoutes };
    }

    function renderVenueToggle(activeType) {
      const types = ['pubs', 'restaurants', 'parks'];
      const labels = { pubs: 'Pubs', restaurants: 'Restaurants', parks: 'Parks' };
      return `<div class="venue-toggle">` +
        types.map(t => `<button class="${t === activeType ? 'active' : ''}" onclick="switchVenueType('${t}')">${labels[t]}</button>`).join('') +
        `</div>`;
    }

    async function loadVenues(type, lat, lon, bounds, btn) {
      const config = VENUE_CONFIG[type];
      const resultsEl = document.getElementById('venue-results');
      if (!resultsEl) return;

      if (btn) btn.textContent = `Finding ${config.label}...`;
      resultsEl.innerHTML = `<div id="pubs-list"><h3>Searching for ${config.label}...</h3></div>`;

      let venues = [];
      let venueError = '';
      try { venues = await findNearbyVenues(lat, lon, type); } catch (e) { venueError = e.message; console.warn('Venue search failed:', e); }

      if (venues.length) {
        venues.forEach((v, i) => {
          const gmapsUrl = googleMapsSearchUrl(v.name, v.lat, v.lon);
          const pm = L.marker([v.lat, v.lon], { icon: pubIcon }).addTo(map)
            .bindPopup(`<b>${i + 1}. ${v.name}</b>${v.addr ? '<br>' + v.addr : ''}<br>${Math.round(v.dist)}m from midpoint<br><a href="${gmapsUrl}" target="_blank">View on Google Maps</a>`);
          pubMarkers.push(pm);
          if (bounds) bounds.extend([v.lat, v.lon]);
        });
        resultsEl.innerHTML = `<div id="pubs-list"><h3>Nearest ${config.label} to midpoint</h3><ol>` +
          venues.map((v, i) => {
            const reviewUrl = googleMapsSearchUrl(v.name, v.lat, v.lon);
            return `<li data-idx="${i}">${v.name} <span>${v.addr ? v.addr + ' \u2022 ' : ''}${v.openingHours ? v.openingHours : Math.round(v.dist) + 'm away'}</span> <a class="review-link" href="${reviewUrl}" target="_blank" onclick="event.stopPropagation()">See reviews</a></li>`;
          }).join('') + `</ol><div id="pub-detail"></div></div>`;
        resultsEl.querySelectorAll('#pubs-list li').forEach(li => {
          li.addEventListener('click', () => {
            const idx = parseInt(li.dataset.idx);
            pubMarkers[idx].openPopup();
            map.panTo(pubMarkers[idx].getLatLng());
            showPubDetail(venues[idx]);
          });
        });
      } else {
        resultsEl.innerHTML = `<div id="pubs-list"><h3>Nearest ${config.label} to midpoint</h3><p style="color:rgba(255,255,255,0.5); padding: 0 36px;">${venueError ? 'Search failed — try again. (' + venueError + ')' : `No ${config.label} found within 5 km.`}</p></div>`;
      }
    }

    async function switchVenueType(type) {
      if (type === currentVenueType || !lastMid) return;
      currentVenueType = type;
      // Update toggle styling
      document.querySelectorAll('.venue-toggle button').forEach(btn => {
        btn.classList.toggle('active', btn.textContent.toLowerCase() === type);
      });
      // Clear existing venue markers
      pubMarkers.forEach(m => map.removeLayer(m));
      pubMarkers = [];
      await loadVenues(type, lastMid.lat, lastMid.lon, null, null);
    }

    async function findMidpoint() {
      const inputs = document.querySelectorAll('#addr-fields .addr-wrap input');
      const addresses = [...inputs].map(el => el.value.trim());
      const errorEl = document.getElementById('error');
      const btn = document.getElementById('findBtn');
      errorEl.textContent = '';

      if (addresses.some(a => !a)) { errorEl.textContent = 'Please enter all addresses.'; return; }
      if (addresses.length < 2) { errorEl.textContent = 'Need at least 2 locations.'; return; }

      // Clear previous results
      markers.forEach(m => map.removeLayer(m));
      markers = [];
      routeLayers.forEach(l => map.removeLayer(l));
      routeLayers = [];
      pubMarkers.forEach(m => map.removeLayer(m));
      pubMarkers = [];
      document.getElementById('info').innerHTML = '';
      document.getElementById('sidebar-wrap').classList.remove('visible', 'collapsed');
      document.getElementById('sidebar-toggle').innerHTML = '&#9664;';
      map.invalidateSize();

      btn.disabled = true;
      btn.textContent = 'Geocoding...';
      updateLoadingProgress(5, 'Geocoding addresses...');

      try {
        // Geocode all addresses (sequentially to respect Nominatim rate limits)
        const locations = [];
        for (let i = 0; i < addresses.length; i++) {
          btn.textContent = `Geocoding (${i + 1}/${addresses.length})...`;
          updateLoadingProgress(5 + Math.round((i + 1) / addresses.length * 15), `Geocoding address ${i + 1} of ${addresses.length}...`);
          locations.push(await geocode(addresses[i]));
          if (i < addresses.length - 1) await new Promise(r => setTimeout(r, 300));
        }

        // Get labels from the rows
        const labels = [...document.querySelectorAll('#addr-fields .addr-label')].map(el => el.value || 'Person');

        // Place location markers
        locations.forEach((loc, i) => {
          const color = ROUTE_COLORS[i % ROUTE_COLORS.length];
          const m = L.marker([loc.lat, loc.lon]).addTo(map)
            .bindPopup(`<b>${labels[i]}</b><br>${loc.name}`);
          markers.push(m);
        });

        // Optimize midpoint
        updateLoadingProgress(25, 'Optimizing meeting point...');
        const mid = await optimizeMidpoint(locations, btn);

        const m3 = L.marker([mid.lat, mid.lon], { icon: redIcon }).addTo(map);
        markers.push(m3);

        const bounds = L.latLngBounds(locations.map(l => [l.lat, l.lon]));
        bounds.extend([mid.lat, mid.lon]);

        // Draw routes and build info
        let drivesHTML = '';
        if (mid.routes) {
          mid.routes.forEach((route, i) => {
            const color = ROUTE_COLORS[i % ROUTE_COLORS.length];
            const line = L.geoJSON(route.geometry, { style: { color, weight: 4, opacity: 0.7 } }).addTo(map);
            routeLayers.push(line);
            bounds.extend(line.getBounds());
            drivesHTML += `<div class="route"><b style="color:${color}">${labels[i]}</b>${formatDuration(route.duration)} &middot; ${formatDistance(route.distance)}</div>`;
          });
        }

        const infoEl = document.getElementById('info');
        let infoHTML = drivesHTML ? `<div class="drives">${drivesHTML}</div>` : '<div style="color:rgba(255,255,255,0.5); padding: 24px 36px;">Driving directions unavailable.</div>';

        // Midpoint popup
        let midPopup = `<b>Drive-time midpoint</b><br>${mid.lat.toFixed(5)}, ${mid.lon.toFixed(5)}`;
        if (mid.routes) {
          mid.routes.forEach((r, i) => { midPopup += `<br>${labels[i]}: ${formatDuration(r.duration)}`; });
        }
        m3.bindPopup(midPopup);

        // Store state for venue toggle re-queries
        lastMid = { lat: mid.lat, lon: mid.lon };
        lastLabels = labels;
        lastRoutes = mid.routes;
        currentVenueType = 'pubs';

        // Add toggle + venue list
        infoHTML += renderVenueToggle('pubs');
        infoHTML += `<div id="venue-results"></div>`;

        infoEl.innerHTML = infoHTML;
        document.getElementById('sidebar-wrap').classList.add('visible');
        map.invalidateSize();

        // Load initial venues
        updateLoadingProgress(75, 'Finding nearby venues...');
        await loadVenues('pubs', mid.lat, mid.lon, bounds, btn);

        updateLoadingProgress(100, 'Done!');
        map.fitBounds(bounds, { padding: [40, 40] });
        m3.openPopup();
        showView('app-view');
      } catch (e) {
        // Show error on landing page and go back
        document.getElementById('landing-error').textContent = e.message;
        showView('landing-view');
      } finally {
        btn.disabled = false;
        btn.textContent = "Let's Meet!";
      }
    }
  </script>
</body>
</html>
